---
layout:     post   				    
title:      多重背包问题				
subtitle:   背包问题[三]
date:       2021-01-06 				
author:     WarmStar
header-img: img/blog11.jpg 	
catalog: true 				
tags:							
    - 算法
---

## 多重背包问题

##### 定义

给定`n`种重量为 `w1, w2, w3, ..., wn`，价值为 `v1, v2, v3, ..., vn`，数量为 `m1, m2, m3, ..., mn`的物品和容量为`c`的背包，找出一种拿取方法使得在满足背包的容量的前提下，包内物品的总价值最大。该问题与`01背包问题`和`完全背包问题`的区别在于每种物品的数量是可能大于1但却是有限个的。

##### 分析

+ 这个问题可以在**完全背包问题**解法的基础上修改：完全背包问题中面对第`i`件物品可以拿取`k`件，其中`0 <= k <= j // w[i - 1]`。这里由于每种物品的数量是定值，所以这里`k`在满足之前的限制条件情况下还要满足`k <= mi`才可以。
+ 这个问题也可以在**01背包问题**解法的基础上修改：由于物品的总数量是有限的，所以对于数量为`mi`的该种物品，直接把它看作`mi`件独立的物品，只是这些物品的重量都为`wi`，价值都为`vi`而已。这样就直接转化为了`01背包问题`了。

<br/>

## 动态规划方法

### 解法1

将多重背包问题看作完全背包问题求解。

##### 递归关系式

直接照搬完全背包问题里的递归关系式，但需多加一个限制条件：

```python
F(i, j) = max{F(i - 1, j - k * wi) + k * vi}	 (0 <= k * wi <= j && k <= mi)
```

##### Python 代码

```python
def bag_multi(n, c, w, v, m):
    """
    :param n: 物品的数量(int type)
    :param c: 背包的容量(int type)
    :param w: 每种物品的重量(list type)
    :param v: 每种物品的价值(list type)
    :param m: 每种物品的数量(list type)
    """
    value = [[0 for j in range(c + 1)] for i in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, c + 1):
            k_limit = min(j // w[i - 1], m[i - 1])
            for k in range(k_limit + 1):
                value[i][j] = max(
                    value[i][j], 
                    value[i - 1][j - k * w[i - 1]] + k * v[i - 1]
                    )
    for v in value:
        print(v)
    return value[n][c]
```

可以看到代码和 [完全背包问题](https://vixeruntr.github.io/2020/12/25/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#python-%E4%BB%A3%E7%A0%81) 相比，除了参数多加了一个表示物品数量的列表外，只有在`k`值的选取范围上多加了一个限制。

<br/>

### 解法2

将多重背包问题转化为01背包问题求解。

##### Python 代码

其实就是直接将数据形式转化成01背包问题的形式就可以了。

```python
def data_trans(w, v, m):
    w_new = []
    v_new = []
    for i in range(len(m)):
        w_new += [w[i]] * m[i]
        v_new += [v[i]] * m[i]
    return sum(m), w_new, v_new

def bag_multi_2(n_, c, w_, v_, m_):
    n, w, v = data_trans(w_, v_, m_)
    value = [[0 for j in range(c + 1)] for i in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, c + 1):
            if j < w[i - 1]:
                value[i][j] = value[i - 1][j]
            if j >= w[i - 1]:
                value[i][j] = max(
                    value[i - 1][j], 
                    value[i - 1][j - w[i - 1]] + v[i - 1]
                )
    for val in value:
        print(val)
    return value[n][c]
```