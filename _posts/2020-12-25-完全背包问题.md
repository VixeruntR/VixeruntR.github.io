---
layout:     post   				    
title:      完全背包问题				
subtitle:   背包问题[二]
date:       2020-12-25 				
author:     WarmStar
header-img: img/blog9.jpg 	
catalog: true 				
tags:							
    - 算法
---

## 完全背包问题

##### 定义

给定`n`种重量为 `w1, w2, w3, ..., wn`, 价值为 `v1, v2, v3, ..., vn` 的物品和容量为`c`的背包，其中这 n 种物品每种均可以无限制地拿取，找出一个拿取方法使得在满足背包的容量的前提下，包内物品的总价值最大。该问题与`01背包问题`的唯一区别就是每种物品的数量是无限制的。

##### 分析

由于这里的物品选取规则不再是限定于`拿或不拿`两种，不再适合画树状图分析了。

最开始看到这个问题，很直接地就想到只拿性价比最高的物品不就可以了，就是只拿`价值/重量`最大的物品，如果有剩余空间的话，再去性价比较低的里面找物品填充。乍一看没毛病，但可以很容易的举出反例：假设有两个物品，物品 A 的价值为 5 重量为 5 ，物品 B 的价值为 8 重量为 6，背包的容量为10。物品 B 的性价比显然要比物品 A 高，如果用上述追求性价比的贪心思路则会只放入一个物品B，但实际上这里选择拿两个物品 A 才是最优解，所以此路不通。

<br/>

## 可行性验证

该问题也可以像`01背包问题`那样使用动态规划方法解决。[01背包问题可行性验证](https://vixeruntr.github.io/2020/11/19/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#%E5%8F%AF%E8%A1%8C%E6%80%A7%E9%AA%8C%E8%AF%81)

##### 最优化原理

这里仍然使用反证法：预设完全背包的解为`F(n1, n2, …, nN)(ni表示第i件物品的选取数量)`。子问题为：将前 i 种物品放入容量为 c 的背包并取得最大价值，其对应的最优解为`F(n1, n2, …, ni)`，假设该解不是子问题的最优解，存在另一组解`F(m1, m2, …, mi)`才是该子问题的最优解，那么`F(m1, m2, …, mi, …, nN) `必然大于`F(n1, n2, …, ni, …, nN)`，则`F(n1, n2, …, nN) `不是原问题的最优解，与预设矛盾，所以`F(n1, n2, …, ni)`必然是子问题的最优解。

##### 无后效性

对于子问题的任意解，都不会影响后续子问题的解，也就是说前 i 种物品无论如何选择，只要最终剩余的背包容量不变，就不会影响后面物品的选择。即满足无后效性。

<br/>

## 动态规划方法

首先定义函数  `F(i, j): 表示背包剩余容量为j时, 前i个物品可以获得的最大价值.`

假设此时已经选择完了前`i-1`个物品并且已经得到了这些物品的最大价值组合，面对第`i`个物品有`k`种选择，即可以选择`0 ~ k`个该物品且满足`0 <= k * wi <= j`:

##### 递归关系式

```
F(i, j) = max{F(i - 1, j - k * wi) + k * vi}	         (0 <= k * wi <= j)	
```

##### Python 代码

第三层 for 循环`k`的范围在`0 ~ (j // w[i - 1]) + 1`，即面对第`i`件物品，可以最少选 0 个，最多选`j // w[i - 1]`个，由它的重量决定。该层循环计算出`k`种结果取最大值。

```python
def bag_comp(n, c, w, v):
    """
    :param n: 物品的数量(int type)
    :param c: 背包的容量(int type)
    :param w: 每种物品的重量(list type)
    :param v: 每种物品的价值(list type)
    """
    value = [[0 for j in range(c + 1)] for i in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, c + 1):
            for k in range((j // w[i - 1]) + 1):
                value[i][j] = max(
                    value[i][j], 
                    value[i - 1][j - k * w[i - 1]] + k * v[i - 1]
                )
    return value[n][c]
```

##### 填表法

为了更直观的理解细节，使用表格法依次填入数据。示例数据设置背包最大容量为10，两组物品的信息如下表：

|  W   |  5   |  6   |
| :--: | :--: | :--: |
|  V   |  5   |  8   |

表中`i`表示`可选择到第i个`物品,  `j`表示剩余的容量大小，表格中的数值即为`F(i, j)`。2个物品的属性按顺序列在表格左侧，方便对照。

1. 先将`i=0`的行与`j=0`列填入0。

   ![bag09.jpg](https://e.im5i.com/2021/01/05/bag09.jpg)

2. 当`i=1`时，只有物品1可以选择，当容量足够(`j>=5`)，最大的价值由物品1的重量和容量决定。当`j=10`时，可选2件该物品，最大价值为10.

   ![bag10.jpg](https://e.im5i.com/2021/01/05/bag10.jpg)

3. 当`i=2`时，两件物品在容量`j`充足的情况下可以任意选择。

   + 当`j=5`时，只能选择一件物品1。对于第`i=2`件物品，k只能为0

     F(2, 5) = F(1, 5 - 0 * w[1]) + 0 * v[1] = F(1, 5) = 5 

   + 当`j=6`时，足够选择一件物品1或者一件物品2。那么对于第`i=2`件物品，k可以是0或1

     当k=0时：F(2, 6) = F(1, 6 - 0 * w[1]) + 0 * v[1] = F(1, 6) + 0 = 5 

     当k=1时：F(2, 6) = F(1, 6 - 1 * w[1]) + 1 * v[1] = F(1, 0) + 8 = 8 

   + 当`j=10`时，对于第`i=2`件物品，k可以是0或1

     当k=0时：F(2, 10) = F(1, 10 - 0 * w[1]) + 0 * v[1] = F(1, 10) + 0 = 10

     当k=1时：F(2, 10) = F(1, 10 - 1 * w[1]) + 1 * v[1] = F(1, 4) + 8 = 8

   ![bag11.jpg](https://e.im5i.com/2021/01/05/bag11.jpg)



### 空间优化

和 [01背包问题](https://vixeruntr.github.io/2020/11/19/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96) 一样，这里也可以进行空间优化。回顾递归关系式，可以发现其实`F(i, j)`仅与`F(i-1, m) {0 <= m <= j}`有关，表格里记录的大量数据是多余的。

对递归关系式进行空间优化可以得到和**01背包问题**复杂度一样的形式：

```python
F(j) = max{F(j), F(j - wi) + vi}	
```

相应的代码为：

```python
def bag_comp(n, c, w, v):
    value = [0] * (c + 1)
    for i in range(1, n + 1):
        for j in range(1, c + 1):
            if w[i - 1] <= j:
                value[j] = max(value[j], value[j - w[i - 1]] + v[i - 1])
    return value[-1]
```

其实这段代码与**01背包问题**空间优化后的代码只有第二层 for 循环那里不同。

**01背包问题** 中是逆序遍历，是为了保证第`i`次循环中的状态`F(i, j)`是由`F(i - 1, j)`递推来的，其实也正是保证了每件物品最多只能被选择一次，即在考虑 “第`i`件物品是否拿取” 时，依据的正是`F(i - 1, j - wi)`，如果正序遍历则会取到`F(i, j - wi)`这个值。

**完全背包问题** 不再限制每件物品的拿取个数，在考虑 “拿取`k`件第`i`件物品” 这个问题时，恰好需要考虑到可能已经选取了第`i`件物品的子结果`F(i, j - wi)`，所以第二层循环正序即可。

