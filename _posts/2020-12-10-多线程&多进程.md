---
layout:     post   				    
title:      Python多线程与多进程 				
subtitle:   
date:       2020-12-10 				
author:     WarmStar 						
header-img: img/blog6.jpg 	
catalog: true 				
tags:							
    - Python
---

> 现在的 PC 都是多核的，使用多线程能充分利用 CPU 以提供程序的执行效率。
>
> 但其实 Python 的多线程是个鸡肋，并不是真正意义上的多线程。



## 简介

##### 线程

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。  

##### 进程

进程是指一个程序在给定数据集合上的一次执行过程，是系统进行资源分配和调度的基本单位。可以简单地理解为操作系统中正在执行的一个程序，也就是说每个程序都有一个自己的独立的进程。每一个进程启动时都会先产生一个主线程，然后主线程再创建子线程。进程是线程的容器，程序是指令、数据及其组织形式的描述，进程是程序的实体。  

##### 线程和进程的区别

这里将进程比作火车，线程比作车厢。

- 线程必须在进程中执行（单纯的车厢无法运行）

- 一个进程可以包含多个线程，有且只有一个主线程（一辆火车可以有多个车厢）

- 不同进程间的数据很难共享（不同火车上的乘客很难互换，需要站点换乘）

- 同一进程下不同线程间数据容易共享（乘客在车厢间走动很容易）

- 进程要比线程消耗更多的计算机资源（总车箱数相同时，列车数越少耗费资源越少）

- 进程间不会相互影响，一个线程挂掉将可能导致整个进程挂掉（一列火车上的某节车厢着火了，将影响到整个列车）

- 进程可以拓展到多机，线程最多适合多核（不同火车可以行驶在不同轨道上，同一火车的车厢不能行驶在不同的轨道上）

- 进程使用的内存地址可以上锁。一个线程使用某些共享内存时，其他线程必须等待它试用结束，才能使用这一块内存。（比如火车上的洗手间）－**互斥锁**

- 进程使用的内存地址可以x限制使用量（比如火车上的餐厅，最多只允许固定数量的乘客进入，如果客满了其余乘客需要等待）－**信号量**  

    

## Python 多线程

### 创建多线程

Python提供的内置的`threading`模块可用于线程的创建和管理。

##### 方法1

直接使用`threading.Thread()`创建：其中`target`参数传递的变量为线程需要执行的函数名(不带括号)，`args`参数传递函数所需的变量(以元组传递)。

```python
import threading

def run(i):
    print("current task:", i)

if __name__ == '__main__':
    t1 = threading.Thread(target=run, args=(1,))
    t2 = threading.Thread(target=run, args=(2,))
    t1.start()
    t2.start()
```

##### 方法2

继承`threading.Thread`自定义线程类，必须重写`run()`方法：因为原始的`threading.Thread`实例在执行`start()`方法后会自动调用`run()`方法，所以这里在继承`threading.Thread`类后，必须将执行函数命名为`run()`。

```python
import threading

class MyThread(threading.Thread):
    def __init__(self, i):
        super(MyThread, self).__init__()
        self.i = i

    def run(self):
        print("current task:", self.i)

if __name__ == "__main__":
    t1 = MyThread(1)
    t2 = MyThread(2)

    t1.start()
    t2.start()
```

### 守护线程

##### setDeamon(bool)

设置当前线程为`后台线程(True)`或`前台线程(False)`，默认为`前台线程(False)`。如果置为后台线程，那么当主线程执行完毕时，无论后台线程是否执行完成，主线程和后台线程均停止；如果置为前台线程，那么当主线程执行完毕时，会等待前台线程执行完成后，程序才停止。  

**这里设置`setDaemon(False)`**

```python
import threading
import time

def run(i):
    time.sleep(1)
    print("current task:", i)
    print("current thread name:", threading.currentThread().getName())
    time.sleep(1)

if __name__ == "__main__":
    for i in range(2):
        t = threading.Thread(target=run, args=(i + 1,))
        t.setDaemon(False)
        t.start()

print('The main thread is finished !')
```

**输出结果：**

```python
The main thread is finished !
current task: 2
current thread name: Thread-2
current task: 1
current thread name: Thread-1
```

**这里设置`setDaemon(True)`**

```python
import threading
import time

def run(i):
    time.sleep(1)
    print("current task:", i)
    print("current thread name:", threading.currentThread().getName())
    time.sleep(1)

if __name__ == "__main__":
    for i in range(2):
        t = threading.Thread(target=run, args=(i + 1,))
        t.setDaemon(True)	
        t.start()

print('The main thread is finished !')
```

**输出结果：**

```python
The main thread is finished !
```

##### join()

`join()`所完成的工作是线程同步，即主线程执行结束后，进入阻塞状态，直到调用此方法的线程执行结束或到达指定的`timeout`时间，否则即使设置了`setDeamon(True)`主线程依然要等待。

```python
import threading
import time

def run(i):
    time.sleep(1)
    print("current task:", i)
    print("current thread name:", threading.currentThread().getName())
    time.sleep(1)

if __name__ == "__main__":
    thread_list = []
    for i in range(2):
        t = threading.Thread(target=run, args=(i + 1,))
        t.setDaemon(True)
        thread_list.append(t)
    for t in thread_list:
        t.start()
    for t in thread_list:
        t.join()

print('The main thread is finished !')
```

**输出结果：**

```python
current task: 1
current thread name: Thread-1
current task: 2
current thread name: Thread-2
The main thread is finished !
```

