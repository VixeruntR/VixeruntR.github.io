---
layout:     post   				    
title:      决策树算法[二] 				
subtitle:    
date:       2021-01-15 				
author:     WarmStar 						
header-img: img/blog14.jpg 	
catalog: true 				
tags:							
    - ML						
---

## sklearn实现决策树

`sklearn.tree`模块提供了决策树的相关算法实现，可以用于分类和回归问题，也提供了对应的可视化函数。

##### 函数介绍

`sklearn.tree`模块提供的`DecisionTreeClassifier`函数可以实现用决策树解决分类问题，该函数的参数如下：

- **criterion：**特征选择的方法，默认是`gini`，也可以设置为`entropy`。`entropy`是香农熵；`gini`是基尼不纯度，表示一个随机样本在子集中被分错的可能性，即该样本被选中的概率乘以它被分错的概率，当一个节点中所有样本都是一个类时，基尼不纯度为零。

- **splitter：**特征划分点的选择标准，默认是`best`，也可以设置为`random`。`best`参数是根据算法的结果选择最佳的切分特征，适合样本量不大的情况；`random`是随机在部分划分点中找**局部最优**的划分点，适合样本量非常大的情况。

- **max_depth：**决策树的最大深度，默认是`None`，此时决策树在建立树的时候不会限制深度，会一直加深直到自然结束。如果样本量很大且特征也多的情况下，根绝实际数据的分布限制最大深度，可能可以得到更好的分类效果。

- **min_samples_split：**内部节点再划分所需最小样本数，默认是2，这个值是限制子树继续划分的条件。如果该参数为整数，那么在切分内部节点的时候，当样本数量小于该值时就会停止切分；如果该参数为浮点数，那么以该值计算出的`math.ceil(min_samples_split * n_samples)`作为可继续切分的最小样本量。

- **min_samples_leaf：**叶子节点上的最小样本数，默认是1。这个值是控制得到的叶子节点是否保留的最小值，当叶子节点上的样本数目小于该值则会被剪枝。如果该值是浮点数，那么计算出`math.celi(min_samples_leaf * n_samples)`作为该最小值。

- **max_features：**

  划分时考虑的最大特征数，可选参数，默认是None。寻找最佳切分时考虑的最大特征数(n_features为总共的特征数)，有如下6种情况：

  - 如果max_features是整型的数，则考虑max_features个特征；
  - 如果max_features是浮点型的数，则考虑int(max_features * n_features)个特征；
  - 如果max_features设为`auto`，那么max_features = sqrt(n_features)；
  - 如果max_features设为`sqrt`，那么max_featrues = sqrt(n_features)，跟`auto`一样；
  - 如果max_features设为`log2`，那么max_features = log2(n_features)；
  - 如果max_features设为`None`，那么max_features = n_features，也就是所有特征都用。
  - 一般来说，如果样本特征数不多，比如小于50，我们用默认的"None"就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。

- **min_weight_fraction_leaf：**叶子节点最小的样本权重和，可选参数，默认是0。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。

- **max_leaf_nodes：**最大叶子节点数，可选参数，默认是`None`。通过限制最大叶子节点数，可以防止过拟合。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。

- **class_weight：**类别权重，可选参数，默认是`None`，也可以字典、字典列表、`balanced`。指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多，导致训练的决策树过于偏向这些类别。类别的权重可以通过`{class_label：weight}`这样的格式给出，这里可以自己指定各个样本的权重，或者用`balanced`，如果使用`balanced`，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。当然，如果你的样本类别分布没有明显的偏倚，则可以不管这个参数，选择默认的`None`。

- **random_state：**可选参数，默认是`None`。随机数种子。如果是证书，那么`random_state`会作为随机数生成器的随机数种子。随机数种子，如果没有设置随机数，随机出来的数与当前系统时间有关，每个时刻都是不同的。如果设置了随机数种子，那么相同随机数种子，不同时刻产生的随机数也是相同的。如果是`RandomState instance`，那么`random_state`是随机数生成器。如果为`None`，则随机数生成器使用np.random。

- **min_impurity_split：**节点划分最小不纯度,可选参数，默认是1e-7。这是个阈值，这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。

- **presort：**数据是否预排序，可选参数，默认为`False`，这个值是布尔值，默认是False不排序。一般来说，如果样本量少或者限制了一个深度很小的决策树，设置为true可以让划分点选择更加快，决策树建立的更加快。如果样本量太大的话，反而没有什么好处。问题是样本量少的时候，我速度本来就不慢。所以这个值一般懒得理它就可以了。